

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>fileutils.interface — Abstract classes. &mdash; Python  documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Python  documentation" href="../index.html" />
    <link rel="next" title="fileutils.local —" href="fileutils.local.html" />
    <link rel="prev" title="fileutils.ftp —" href="fileutils.ftp.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="fileutils.local.html" title="fileutils.local —"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="fileutils.ftp.html" title="fileutils.ftp —"
             accesskey="P">previous</a> |</li>
        <li><a href="../contents.html">Python  documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-fileutils.interface">
<span id="fileutils-interface-abstract-classes"></span><h1><a class="reference internal" href="#module-fileutils.interface" title="fileutils.interface: Abstract classes."><tt class="xref py py-mod docutils literal"><span class="pre">fileutils.interface</span></tt></a> &#8212; Abstract classes.<a class="headerlink" href="#module-fileutils.interface" title="Permalink to this headline">¶</a></h1>
<p>This module contains all of the abstract classes that define the public API for
fileutils.</p>
<div class="section" id="class-filesystem">
<h2>Class FileSystem<a class="headerlink" href="#class-filesystem" title="Permalink to this headline">¶</a></h2>
<p>An abstract class representing an entire file system hierarchy.</p>
<p>Instances of this class are typically obtained by directly instantiating
its subclasses. The most commonly used subclass,
<a class="reference internal" href="fileutils.local.html#fileutils.local.LocalFileSystem" title="fileutils.local.LocalFileSystem"><tt class="xref py py-obj docutils literal"><span class="pre">LocalFileSystem</span></tt></a>, maintains
a singleton instance that corresponds to the filesystem of the local
machine. Other subclasses include
<a class="reference internal" href="fileutils.ssh.html#fileutils.ssh.SSHFileSystem" title="fileutils.ssh.SSHFileSystem"><tt class="xref py py-obj docutils literal"><span class="pre">SSHFileSystem</span></tt></a>.</p>
<dl class="class">
<dt id="fileutils.interface.FileSystem">
<em class="property">class </em><tt class="descclassname">fileutils.interface.</tt><tt class="descname">FileSystem</tt><a class="headerlink" href="#fileutils.interface.FileSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
<dl class="method">
<dt id="fileutils.interface.FileSystem.child">
<tt class="descname">child</tt><big>(</big><em>self</em>, <em>path</em><big>)</big><a class="headerlink" href="#fileutils.interface.FileSystem.child" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an instance of <a class="reference internal" href="#fileutils.interface.BaseFile" title="fileutils.interface.BaseFile"><tt class="xref py py-obj docutils literal"><span class="pre">BaseFile</span></tt></a> representing the file located at
the specific path.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.FileSystem.mountpoints">
<tt class="descname">mountpoints</tt><a class="headerlink" href="#fileutils.interface.FileSystem.mountpoints" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of <a class="reference internal" href="#fileutils.interface.MountPoint" title="fileutils.interface.MountPoint"><tt class="xref py py-obj docutils literal"><span class="pre">MountPoint</span></tt></a> instances corresponding to all mount points
on the system.</p>
<p>On Windows, there will be exactly one mount point for each drive
letter. On POSIX systems, there will be one mount point per, well,
mount point.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.FileSystem.root">
<tt class="descname">root</tt><a class="headerlink" href="#fileutils.interface.FileSystem.root" title="Permalink to this definition">¶</a></dt>
<dd><p>A sensible &#8220;default&#8221; root for this file system, or None if there isn&#8217;t
really any sensible default.</p>
<p>The default implementation just returns self.roots[0].</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.FileSystem.roots">
<tt class="descname">roots</tt><a class="headerlink" href="#fileutils.interface.FileSystem.roots" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of all of the file system hierarchy roots exposes by this
FileSystem instance, as <a class="reference internal" href="#fileutils.interface.BaseFile" title="fileutils.interface.BaseFile"><tt class="xref py py-obj docutils literal"><span class="pre">BaseFile</span></tt></a> instances.</p>
<p>On Windows, there will be one root per drive letter. On POSIX systems,
there will be exactly one root, namely &#8216;/&#8217;.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-mountpoint">
<h2>Class MountPoint<a class="headerlink" href="#class-mountpoint" title="Permalink to this headline">¶</a></h2>
<p>An abstract class representing mount points on a file system.</p>
<p>Instances of this class can be obtained from <a class="reference internal" href="#fileutils.interface.BaseFile.mountpoint" title="fileutils.interface.BaseFile.mountpoint"><tt class="xref py py-obj docutils literal"><span class="pre">mountpoint</span></tt></a>, a
property that returns the MountPoint instance on which the file in question
resides. They can also be obtained from <a class="reference internal" href="#fileutils.interface.FileSystem.mountpoints" title="fileutils.interface.FileSystem.mountpoints"><tt class="xref py py-obj docutils literal"><span class="pre">mountpoints</span></tt></a>, a
property that returns a list of all of the system&#8217;s mount points.</p>
<dl class="class">
<dt id="fileutils.interface.MountPoint">
<em class="property">class </em><tt class="descclassname">fileutils.interface.</tt><tt class="descname">MountPoint</tt><a class="headerlink" href="#fileutils.interface.MountPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
<dl class="attribute">
<dt id="fileutils.interface.MountPoint.available_space">
<tt class="descname">available_space</tt><a class="headerlink" href="#fileutils.interface.MountPoint.available_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Shorthand for self.<a class="reference internal" href="#fileutils.interface.MountPoint.usage" title="fileutils.interface.MountPoint.usage"><tt class="xref py py-obj docutils literal"><span class="pre">usage</span></tt></a>.<a class="reference internal" href="#fileutils.interface.DiskUsage.space" title="fileutils.interface.DiskUsage.space"><tt class="xref py py-obj docutils literal"><span class="pre">space</span></tt></a>.<a class="reference internal" href="#fileutils.interface.Usage.available" title="fileutils.interface.Usage.available"><tt class="xref py py-obj docutils literal"><span class="pre">available</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.MountPoint.device">
<tt class="descname">device</tt><a class="headerlink" href="#fileutils.interface.MountPoint.device" title="Permalink to this definition">¶</a></dt>
<dd><p>An instance of <a class="reference internal" href="#fileutils.interface.MountDevice" title="fileutils.interface.MountDevice"><tt class="xref py py-obj docutils literal"><span class="pre">MountDevice</span></tt></a> representing the topmost device
currently mounted at this mount point. This is the device whose data is
currently available at this mount point.</p>
<p>This is just short for :obj:<a href="#id1"><span class="problematic" id="id2">`</span></a>self.devices &lt;devices&gt;`[-1], but if
self.devices is empty, None will be returned instead.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.MountPoint.devices">
<tt class="descname">devices</tt><a class="headerlink" href="#fileutils.interface.MountPoint.devices" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of instances of <a class="reference internal" href="#fileutils.interface.MountDevice" title="fileutils.interface.MountDevice"><tt class="xref py py-obj docutils literal"><span class="pre">MountDevice</span></tt></a> representing all of the
devices currently mounted at this mount point, in the order in which
they were attached. The last of these is the device whose data is
currently available at this mount point.</p>
<p>Not all systems support stacks of devices mounted at the same
mount point. For systems that don&#8217;t support this, there will never be
more than one device mounted at any given mount point. For systems that
do (such as Linux), unmounting a mount point simply causes the last
device attached to the mount point to be popped off the stack, and the
next device&#8217;s data is made available at that mount point.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.MountPoint.filesystem">
<tt class="descname">filesystem</tt><a class="headerlink" href="#fileutils.interface.MountPoint.filesystem" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#fileutils.interface.FileSystem" title="fileutils.interface.FileSystem"><tt class="xref py py-obj docutils literal"><span class="pre">FileSystem</span></tt></a> instance on which this mount point resides.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.MountPoint.free_space">
<tt class="descname">free_space</tt><a class="headerlink" href="#fileutils.interface.MountPoint.free_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Shorthand for self.<a class="reference internal" href="#fileutils.interface.MountPoint.usage" title="fileutils.interface.MountPoint.usage"><tt class="xref py py-obj docutils literal"><span class="pre">usage</span></tt></a>.<a class="reference internal" href="#fileutils.interface.DiskUsage.space" title="fileutils.interface.DiskUsage.space"><tt class="xref py py-obj docutils literal"><span class="pre">space</span></tt></a>.<a class="reference internal" href="#fileutils.interface.Usage.free" title="fileutils.interface.Usage.free"><tt class="xref py py-obj docutils literal"><span class="pre">free</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.MountPoint.location">
<tt class="descname">location</tt><a class="headerlink" href="#fileutils.interface.MountPoint.location" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#fileutils.interface.BaseFile" title="fileutils.interface.BaseFile"><tt class="xref py py-obj docutils literal"><span class="pre">BaseFile</span></tt></a> instance indicating the directory at which this
mount point is mounted.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.MountPoint.total_space">
<tt class="descname">total_space</tt><a class="headerlink" href="#fileutils.interface.MountPoint.total_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Shorthand for self.<a class="reference internal" href="#fileutils.interface.MountPoint.usage" title="fileutils.interface.MountPoint.usage"><tt class="xref py py-obj docutils literal"><span class="pre">usage</span></tt></a>.<a class="reference internal" href="#fileutils.interface.DiskUsage.space" title="fileutils.interface.DiskUsage.space"><tt class="xref py py-obj docutils literal"><span class="pre">space</span></tt></a>.<a class="reference internal" href="#fileutils.interface.Usage.total" title="fileutils.interface.Usage.total"><tt class="xref py py-obj docutils literal"><span class="pre">total</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.MountPoint.unmount">
<tt class="descname">unmount</tt><big>(</big><em>self</em>, <em>force=True</em><big>)</big><a class="headerlink" href="#fileutils.interface.MountPoint.unmount" title="Permalink to this definition">¶</a></dt>
<dd><p>Unmount the topmost device attached to this mount point.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.MountPoint.usage">
<tt class="descname">usage</tt><a class="headerlink" href="#fileutils.interface.MountPoint.usage" title="Permalink to this definition">¶</a></dt>
<dd><p>An instance of <a class="reference internal" href="#fileutils.interface.DiskUsage" title="fileutils.interface.DiskUsage"><tt class="xref py py-obj docutils literal"><span class="pre">DiskUsage</span></tt></a> indicating the current disk and inode
usage for this mount point.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.MountPoint.used_space">
<tt class="descname">used_space</tt><a class="headerlink" href="#fileutils.interface.MountPoint.used_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Shorthand for self.<a class="reference internal" href="#fileutils.interface.MountPoint.usage" title="fileutils.interface.MountPoint.usage"><tt class="xref py py-obj docutils literal"><span class="pre">usage</span></tt></a>.<a class="reference internal" href="#fileutils.interface.DiskUsage.space" title="fileutils.interface.DiskUsage.space"><tt class="xref py py-obj docutils literal"><span class="pre">space</span></tt></a>.<a class="reference internal" href="#fileutils.interface.Usage.used" title="fileutils.interface.Usage.used"><tt class="xref py py-obj docutils literal"><span class="pre">used</span></tt></a>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-mountdevice">
<h2>Class MountDevice<a class="headerlink" href="#class-mountdevice" title="Permalink to this headline">¶</a></h2>
<p>A device as mounted under a particular mount point.</p>
<p>Note: The API of this class is still in flux. I&#8217;m particularly considering
splitting it into two classes whose names are yet to be decided, one of
which will contain every property except subpath and the other of which
will contain two properties, subpath and device, the latter pointing to an
instance of the former class. Bear this in mind when writing code that uses
this class.</p>
<dl class="class">
<dt id="fileutils.interface.MountDevice">
<em class="property">class </em><tt class="descclassname">fileutils.interface.</tt><tt class="descname">MountDevice</tt><a class="headerlink" href="#fileutils.interface.MountDevice" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
<dl class="attribute">
<dt id="fileutils.interface.MountDevice.device">
<tt class="descname">device</tt><a class="headerlink" href="#fileutils.interface.MountDevice.device" title="Permalink to this definition">¶</a></dt>
<dd><p>A textual representation of this device, if the subclass exposes such
information.</p>
<p>If <a class="reference internal" href="#fileutils.interface.MountDevice.location" title="fileutils.interface.MountDevice.location"><tt class="xref py py-obj docutils literal"><span class="pre">self.location</span></tt></a> is not None, this will be
self.location.path.</p>
<p>On Linux, for special file system types, this will be the name of the
type in question; &#8216;tmpfs&#8217;, for example.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.MountDevice.location">
<tt class="descname">location</tt><a class="headerlink" href="#fileutils.interface.MountDevice.location" title="Permalink to this definition">¶</a></dt>
<dd><p>The location of this device as a <a class="reference internal" href="#fileutils.interface.BaseFile" title="fileutils.interface.BaseFile"><tt class="xref py py-obj docutils literal"><span class="pre">BaseFile</span></tt></a> instance, if the subclass
exposes mount point devices in the form of a file in the file system
hierarchy. On Linux, for example, this might be something like
File(&#8216;/dev/sda1&#8217;). On Windows this will be None, and it will also be
None on Linux for special file systems like tmpfs that don&#8217;t have any
representation in the file system hierarchy.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.MountDevice.subpath">
<tt class="descname">subpath</tt><a class="headerlink" href="#fileutils.interface.MountDevice.subpath" title="Permalink to this definition">¶</a></dt>
<dd><p>The subpath, as a string containing an absolute path, of the file
system located on this device being exposed to the mount point on which
this device is mounted, or None if the subclass doesn&#8217;t support such a
notion.</p>
<p>For most mount devices that support this, this will just be &#8220;/&#8221;. It can
be a different path when a nested path within a particular file system
is exposed with a bind mount; in such a case, this is the path within
the file system being exposed at the mount point on which this device
is mounted.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-diskusage">
<h2>Class DiskUsage<a class="headerlink" href="#class-diskusage" title="Permalink to this headline">¶</a></h2>
<p>Disk space and inode usage.</p>
<p>Instances of this class are typically obtained from
<a class="reference internal" href="#fileutils.interface.MountPoint.usage" title="fileutils.interface.MountPoint.usage"><tt class="xref py py-obj docutils literal"><span class="pre">MountPoint.usage</span></tt></a>.</p>
<dl class="class">
<dt id="fileutils.interface.DiskUsage">
<em class="property">class </em><tt class="descclassname">fileutils.interface.</tt><tt class="descname">DiskUsage</tt><big>(</big><em>self</em>, <em>space</em>, <em>inodes</em><big>)</big><a class="headerlink" href="#fileutils.interface.DiskUsage" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="fileutils.interface.DiskUsage.__repr__">
<tt class="descname">__repr__</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#fileutils.interface.DiskUsage.__repr__" title="Permalink to this definition">¶</a></dt>
<dt id="fileutils.interface.DiskUsage.__str__">
<tt class="descname">__str__</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#fileutils.interface.DiskUsage.__str__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.DiskUsage.inodes">
<tt class="descname">inodes</tt><a class="headerlink" href="#fileutils.interface.DiskUsage.inodes" title="Permalink to this definition">¶</a></dt>
<dd><p>An instance of <a class="reference internal" href="#fileutils.interface.Usage" title="fileutils.interface.Usage"><tt class="xref py py-obj docutils literal"><span class="pre">Usage</span></tt></a> indicating utilization of inodes, or None
on platforms (like Windows) that don&#8217;t have such a concept.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.DiskUsage.space">
<tt class="descname">space</tt><a class="headerlink" href="#fileutils.interface.DiskUsage.space" title="Permalink to this definition">¶</a></dt>
<dd><p>An instance of <a class="reference internal" href="#fileutils.interface.Usage" title="fileutils.interface.Usage"><tt class="xref py py-obj docutils literal"><span class="pre">Usage</span></tt></a> indicating utilization of disk space.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-usage">
<h2>Class Usage<a class="headerlink" href="#class-usage" title="Permalink to this headline">¶</a></h2>
<p>Usage of a particular file system resource, such as disk space (given in
bytes) or inodes.</p>
<dl class="class">
<dt id="fileutils.interface.Usage">
<em class="property">class </em><tt class="descclassname">fileutils.interface.</tt><tt class="descname">Usage</tt><big>(</big><em>self</em>, <em>total</em>, <em>used</em>, <em>available</em><big>)</big><a class="headerlink" href="#fileutils.interface.Usage" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="fileutils.interface.Usage.__repr__">
<tt class="descname">__repr__</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#fileutils.interface.Usage.__repr__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.Usage.available">
<tt class="descname">available</tt><a class="headerlink" href="#fileutils.interface.Usage.available" title="Permalink to this definition">¶</a></dt>
<dd><p>Amount of free disk space or number of inodes available to the current
user.</p>
<p>This is often the same as <a class="reference internal" href="#fileutils.interface.Usage.free" title="fileutils.interface.Usage.free"><tt class="xref py py-obj docutils literal"><span class="pre">self.free</span></tt></a>, but things like disk
space quotas and blocks reserved for the superuser can make it have a
value less than that of self.free.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.Usage.free">
<tt class="descname">free</tt><a class="headerlink" href="#fileutils.interface.Usage.free" title="Permalink to this definition">¶</a></dt>
<dd><p>Amount of disk space or number of inodes not currently in use.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.Usage.total">
<tt class="descname">total</tt><a class="headerlink" href="#fileutils.interface.Usage.total" title="Permalink to this definition">¶</a></dt>
<dd><p>Total amount of disk space or inodes available.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.Usage.used">
<tt class="descname">used</tt><a class="headerlink" href="#fileutils.interface.Usage.used" title="Permalink to this definition">¶</a></dt>
<dd><p>Amount of disk space or number of inodes currently in use.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-basefile">
<h2>Class BaseFile<a class="headerlink" href="#class-basefile" title="Permalink to this headline">¶</a></h2>
<p>An abstract class representing an absolute path to a file on a particular
FileSystem instance.</p>
<p>Instances of this class can be obtained from
<a class="reference internal" href="#fileutils.interface.FileSystem.child" title="fileutils.interface.FileSystem.child"><tt class="xref py py-obj docutils literal"><span class="pre">FileSystem.child()</span></tt></a> &lt;FileSystem.child&gt;`. They can also be obtained
from <a class="reference internal" href="#fileutils.interface.FileSystem.roots" title="fileutils.interface.FileSystem.roots"><tt class="xref py py-obj docutils literal"><span class="pre">FileSystem.roots</span></tt></a>, a property providing a list of all
of the file system&#8217;s root directories.</p>
<dl class="class">
<dt id="fileutils.interface.BaseFile">
<em class="property">class </em><tt class="descclassname">fileutils.interface.</tt><tt class="descname">BaseFile</tt><a class="headerlink" href="#fileutils.interface.BaseFile" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
<dl class="method">
<dt id="fileutils.interface.BaseFile.__div__">
<tt class="descname">__div__</tt><big>(</big><em>self</em>, <em>other</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.__div__" title="Permalink to this definition">¶</a></dt>
<dd><p>An absolutely pointless and unnecessary alias for self.child(other)
that exists solely because I was overly bored one night while working
on fileutils.</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.ancestor_of">
<tt class="descname">ancestor_of</tt><big>(</big><em>self</em>, <em>other</em>, <em>including_self=False</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.ancestor_of" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if this file is an ancestor of the specified file. A file
is an ancestor of another file if that other file&#8217;s parent is (as
decided by <a class="reference internal" href="#fileutils.interface.BaseFile.same_as" title="fileutils.interface.BaseFile.same_as"><tt class="xref py py-obj docutils literal"><span class="pre">same_as</span></tt></a>) this file, or its parent&#8217;s parent is this
file, and so on.</p>
<p>If including_self is True, the file is considered to be an ancestor of
itself, i.e. True will be returned in the case that self.same_as(other).
Otherwise, only the file&#8217;s immediate parent, and its parent&#8217;s parent,
and so on are considered to be ancestors.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.BaseFile.ancestors">
<tt class="descname">ancestors</tt><a class="headerlink" href="#fileutils.interface.BaseFile.ancestors" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of all of the ancestors of this file, with self.parent first.</p>
<p>This property simply returns
<a class="reference internal" href="#fileutils.interface.BaseFile.get_ancestors" title="fileutils.interface.BaseFile.get_ancestors"><tt class="xref py py-obj docutils literal"><span class="pre">self.get_ancestors()</span></tt></a>. Have a look at that
method if you need to do more complex things like include self as one
of the returned ancestors.</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.append">
<tt class="descname">append</tt><big>(</big><em>self</em>, <em>data</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append the specified data to the end of this file.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.BaseFile.as_working">
<tt class="descname">as_working</tt><a class="headerlink" href="#fileutils.interface.BaseFile.as_working" title="Permalink to this definition">¶</a></dt>
<dd><p>A property that returns a context manager. This context manager sets
the working directory to self upon being entered and restores it to
what it previously was upon being exited. One can use this to replace
something like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">old_dir</span> <span class="o">=</span> <span class="n">File</span><span class="p">()</span>
<span class="n">new_dir</span><span class="o">.</span><span class="n">cd</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="o">...</span><span class="n">stuff</span><span class="o">...</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">old_dir</span><span class="o">.</span><span class="n">cd</span><span class="p">()</span>
</pre></div>
</div>
<p>with the much nicer:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">new_dir</span><span class="o">.</span><span class="n">as_working</span><span class="p">:</span>
    <span class="o">...</span><span class="n">stuff</span><span class="o">...</span>
</pre></div>
</div>
<p>and get exactly the same effect.</p>
<p>The context manager&#8217;s __enter__ returns self (this file), so you can
also use an &#8220;as&#8221; clause on the with statement to get access to the
file in case you haven&#8217;t got it stored in a variable anywhere.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.BaseFile.attributes">
<tt class="descname">attributes</tt><a class="headerlink" href="#fileutils.interface.BaseFile.attributes" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the new attributes system. It&#8217;s highly experimental, so beware
that it might not work as expected and that its API could change
without notice. More to come.</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.cd">
<tt class="descname">cd</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.cd" title="Permalink to this definition">¶</a></dt>
<dd><p>An alias for <a class="reference internal" href="#fileutils.interface.BaseFile.change_to" title="fileutils.interface.BaseFile.change_to"><tt class="xref py py-obj docutils literal"><span class="pre">self.change_to()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.change_to">
<tt class="descname">change_to</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.change_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the current working directory to self.</p>
<p>Since File instances internally store paths in absolute form, other
File instances will continue to work just fine after this is called.</p>
<p>If you need to restore the working directory at any point, you might
want to consider using <a class="reference internal" href="#fileutils.interface.BaseFile.as_working" title="fileutils.interface.BaseFile.as_working"><tt class="xref py py-obj docutils literal"><span class="pre">self.as_working</span></tt></a> instead.</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.check_file">
<tt class="descname">check_file</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.check_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks to see whether this File refers to a file. If it doesn&#8217;t, an
exception will be thrown.</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.check_folder">
<tt class="descname">check_folder</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.check_folder" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks to see whether this File refers to a folder. If it doesn&#8217;t, an
exception will be thrown.</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.child">
<tt class="descname">child</tt><big>(</big><em>self</em>, <em>*names</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.child" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a file object representing the child of this file with the
specified name. If multiple names are present, they will be joined
together. If no names are present, self will be returned.</p>
<p>If any names are absolute, all names before them (and self) will be
discarded. Relative names (like &#8221;..&#8221;) are also allowed. If you want a
method that guarantees that the result is a child of self, use
self.safe_child(...).</p>
<p>This method is analogous to
<a class="reference external" href="http://docs.python.org/2.7/library/os.path.html#os.path.join" title="(in Python v2.7)"><tt class="xref py py-obj docutils literal"><span class="pre">os.path.join(self.path,</span> <span class="pre">*names)</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.BaseFile.child_names">
<tt class="descname">child_names</tt><a class="headerlink" href="#fileutils.interface.BaseFile.child_names" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of the names of all of the children of this file, as a list of
strings. If this file is not a folder, the value of this property is
None.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.BaseFile.children">
<tt class="descname">children</tt><a class="headerlink" href="#fileutils.interface.BaseFile.children" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of all of the children of this file, as a list of File objects.
If this file is not a folder, the value of this property is None.</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.copy_attributes_to">
<tt class="descname">copy_attributes_to</tt><big>(</big><em>self</em>, <em>other</em>, <em>which_attributes={}</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.copy_attributes_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy file/directory attributes from self to other.</p>
<p>which_attributes is a dictionary indicating which attribute sets are
to be copied. The keys are subclasses of AttributeSet (these are class
objects themselves, not instances of said classes) and the values
indicate whether, and how, attribute sets are to be copied:</p>
<blockquote>
<div><p>True indicates that the attribute set in question should be copied.
The copying will be performed with the attribute set&#8217;s copy_to
method.</p>
<p>False indicates that the attribute set in question should not be
copied.</p>
<p>A two-argument function can be used to copy attributes in a custom
manner. The function will be called with the source attribute set
as the first argument and the target attribute set as the second
argument.</p>
</div></blockquote>
<p>One additional key, None, can be specified. Its value indicates
whether, and how, all attribute sets not explicitly specified in the
dictionary are to be copied. If not specified, each attribute set&#8217;s
copy_by_default property is used to decide whether or not to copy that
attribute set.</p>
<p>To copy POSIX permissions and mode bits only, and nothing else, one
could use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">foo</span><span class="o">.</span><span class="n">copy_attributes_to</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span> <span class="p">{</span><span class="n">PosixPermissions</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">None</span><span class="p">:</span> <span class="bp">False</span><span class="p">})</span>
</pre></div>
</div>
<p>To skip copying of POSIX permissions and mode bits but copy everything
else, one could use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">foo</span><span class="o">.</span><span class="n">copy_attributes_to</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span> <span class="p">{</span><span class="n">PosixPermissions</span><span class="p">:</span> <span class="bp">False</span><span class="p">})</span>
</pre></div>
</div>
<p>To copy only the extended attribute &#8220;user.foo&#8221;, one could use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">copy_user_foo</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="n">target</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;user.foo&quot;</span><span class="p">,</span> <span class="n">source</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;user.foo&quot;</span><span class="p">))</span>
<span class="n">foo</span><span class="o">.</span><span class="n">copy_attributes_to</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span> <span class="p">{</span><span class="n">ExtendedAttributes</span><span class="p">:</span> <span class="n">copy_user_foo</span><span class="p">,</span>
                             <span class="bp">None</span><span class="p">:</span> <span class="bp">False</span><span class="p">})</span>
</pre></div>
</div>
<p>(This example would be easier written as:</p>
<div class="highlight-python"><pre>bar.attributes[ExtendedAttributes].set("user.foo,
    foo.attributes[ExtendedAttributes].get("user.foo"))</pre>
</div>
<p>so take it as purely an example.)</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.copy_into">
<tt class="descname">copy_into</tt><big>(</big><em>self</em>, <em>other</em>, <em>overwrite=False</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.copy_into" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies this file to an identically named file inside the specified
folder. This is just shorthand for self.copy_to(other.child(self.name))
which, from experience, seems to be by far the most common use case for
the copy_to function.</p>
<p>The newly-created file in the specified folder will be returned as per
other.child(self.name).</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.copy_to">
<tt class="descname">copy_to</tt><big>(</big><em>self</em>, <em>other</em>, <em>overwrite=False</em>, <em>dereference_links=True</em>, <em>attribute_sets=None</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.copy_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies the contents of this file to the specified file object. An
exception will be thrown if the specified file already exists and
overwrite is False.</p>
<p>If dereference_links is True (the default), symbolic links encountered
during copying will be dereferenced and their targets copied in their
place. If dereference_links is False, such links will be recreated
purely as symbolic links.</p>
<p>This also does not currently preserve file attributes or permissions;
such abilities will be added soon.</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.create_folder">
<tt class="descname">create_folder</tt><big>(</big><em>self</em>, <em>ignore_existing=False</em>, <em>recursive=False</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.create_folder" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the folder referred to by this File object. If it already
exists but is not a folder, an exception will be thrown. If it already
exists and is a folder, an exception will be thrown if ignore_existing
is False (the default); if ignore_existing is True, no exception will
be thrown.</p>
<p>If the to-be-created folder&#8217;s parent does not exist and recursive is
False, an exception will be thrown. If recursive is True, the folder&#8217;s
parent, its parent&#8217;s parent, and so on will be created automatically.</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.delete">
<tt class="descname">delete</tt><big>(</big><em>self</em>, <em>ignore_missing=False</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes this file or folder, recursively deleting children if
necessary.</p>
<p>The contents parameter has no effect, and is present for backward
compatibility.</p>
<p>If the file does not exist and ignore_missing is False, an exception
will be thrown. If the file does not exist but ignore_missing is True,
this function simply does nothing.</p>
<p>Note that symbolic links are never recursed into, and are instead
themselves removed.</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.dereference">
<tt class="descname">dereference</tt><big>(</big><em>self</em>, <em>recursive=False</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.dereference" title="Permalink to this definition">¶</a></dt>
<dd><p>Dereference the symbolic link represented by this file and return a
File object pointing to the symbolic link&#8217;s referent.</p>
<p>If recursive is False, a File object pointing directly to the referent
will be returned. If recursive is True, the referent itself will be
recursively dereferenced, and the returned File will be guaranteed not
to be a link.</p>
<p>If this file is not a symbolic link, self will be returned.</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.descendant_of">
<tt class="descname">descendant_of</tt><big>(</big><em>self</em>, <em>other</em>, <em>including_self=False</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.descendant_of" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if this file is a descendant of the specified file. This
is equivalent to other.ancestor_of(self, including_self).</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.BaseFile.exists">
<tt class="descname">exists</tt><a class="headerlink" href="#fileutils.interface.BaseFile.exists" title="Permalink to this definition">¶</a></dt>
<dd><p>True if this file/folder exists, False if it doesn&#8217;t. This will be True
even for broken symbolic links; use self.valid if you want an
alternative that returns False for broken symbolic links.</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.get_ancestors">
<tt class="descname">get_ancestors</tt><big>(</big><em>self</em>, <em>including_self=False</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.get_ancestors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of all of the ancestors of this file, with self.parent
first. If including_self is True, self will be first, self.parent will
be second, and so on.</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.get_path">
<tt class="descname">get_path</tt><big>(</big><em>self</em>, <em>relative_to=None</em>, <em>separator=None</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.get_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the path to the file represented by this File object.</p>
<p>If relative_to is specified, the returned path will be a relative path,
the path of this file relative to the specified one. Otherwise, the
returned path will be absolute.</p>
<p>If separator (which must be a string) is specified, it will be used as
the separator to place between path components in the returned path.
Otherwise, os.path.sep will be used as the separator.</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.get_path_components">
<tt class="descname">get_path_components</tt><big>(</big><em>self</em>, <em>relative_to=None</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.get_path_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of the components in this file&#8217;s path, including (on
POSIX-compliant systems) an empty leading component for absolute paths.</p>
<p>If relative_to is specified, the returned set of components will
represent a relative path, the path of this file relative to the
specified one. Otherwise, the returned components will represent an
absolute path.</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.hash">
<tt class="descname">hash</tt><big>(</big><em>self</em>, <em>algorithm=&lt;built-in function openssl_md5&gt;</em>, <em>return_hex=True</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the hash of this file and return it, as a hexidecimal string.</p>
<p>The default algorithm is md5. An alternate constructor from hashlib
can be passed as the algorithm parameter; file.hash(hashlib.sha1)
would, for example, compute the SHA-1 hash instead.</p>
<p>If return_hex is False (it defaults to True), the hash object itself
will be returned instead of the return value of its hexdigest() method.
One can use this to access the binary hash instead.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.BaseFile.is_broken">
<tt class="descname">is_broken</tt><a class="headerlink" href="#fileutils.interface.BaseFile.is_broken" title="Permalink to this definition">¶</a></dt>
<dd><p>True if this File is a symbolic link that is broken, False if it isn&#8217;t.
A symbolic link that points to a broken symbolic link is itself
considered to be broken.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.BaseFile.is_directory">
<tt class="descname">is_directory</tt><a class="headerlink" href="#fileutils.interface.BaseFile.is_directory" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.is_folder.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.BaseFile.is_file">
<tt class="descname">is_file</tt><a class="headerlink" href="#fileutils.interface.BaseFile.is_file" title="Permalink to this definition">¶</a></dt>
<dd><p>True if this File is a file, False if it isn&#8217;t. If the file/folder
doesn&#8217;t actually exist yet, this will be False.</p>
<p>If this file is a symbolic link that points to a file, this will be
True.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.BaseFile.is_folder">
<tt class="descname">is_folder</tt><a class="headerlink" href="#fileutils.interface.BaseFile.is_folder" title="Permalink to this definition">¶</a></dt>
<dd><p>True if this File is a folder, False if it isn&#8217;t. If the file/folder
doesn&#8217;t actually exist yet, this will be False.</p>
<p>If this file is a symbolic link that points to a folder, this will be
True.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.BaseFile.is_link">
<tt class="descname">is_link</tt><a class="headerlink" href="#fileutils.interface.BaseFile.is_link" title="Permalink to this definition">¶</a></dt>
<dd><p>True if this File is a symbolic link, False if it isn&#8217;t. This will be
True even for broken symbolic links.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.BaseFile.is_mount">
<tt class="descname">is_mount</tt><a class="headerlink" href="#fileutils.interface.BaseFile.is_mount" title="Permalink to this definition">¶</a></dt>
<dd><p>True if this File is a mount point, False if it isn&#8217;t.</p>
<p>This is just short for self.mountpoint.location == self.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.BaseFile.link_target">
<tt class="descname">link_target</tt><a class="headerlink" href="#fileutils.interface.BaseFile.link_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the target to which this file, which is expected to be a
symbolic link, points, as a string. If this file is not a symbolic
link, None is returned.</p>
<p>Subclasses (such as URL) without a well-defined notion of symbolic
links are free to interpret this as they wish; URL, for example,
presents as a link any URL which sends back an HTTP redirect.</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.link_to">
<tt class="descname">link_to</tt><big>(</big><em>self</em>, <em>target</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.link_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates this file as a symbolic link pointing to other, which can be
a pathname or an object of the same type as self. Note that if it&#8217;s a
pathname, a symbolic link will be created with the exact path
specified; it will therefore be absolute if the path is absolute or
relative (to the link itself) if the path is relative. If an object of
the same type as self, however, is used, the symbolic link will always
be absolute.</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.mkdir">
<tt class="descname">mkdir</tt><big>(</big><em>self</em>, <em>silent=False</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.mkdir" title="Permalink to this definition">¶</a></dt>
<dd><p>An alias for self.create_folder(ignore_existing=silent).</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.mkdirs">
<tt class="descname">mkdirs</tt><big>(</big><em>self</em>, <em>silent=False</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.mkdirs" title="Permalink to this definition">¶</a></dt>
<dt id="fileutils.interface.BaseFile.makedirs">
<tt class="descname">makedirs</tt><big>(</big><em>self</em>, <em>silent=False</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.makedirs" title="Permalink to this definition">¶</a></dt>
<dd><p>An alias for self.create_folder(ignore_existing=silent, recursive=True).</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.BaseFile.mountpoint">
<tt class="descname">mountpoint</tt><a class="headerlink" href="#fileutils.interface.BaseFile.mountpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>The MountPoint instance on which this file resides.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.BaseFile.name">
<tt class="descname">name</tt><a class="headerlink" href="#fileutils.interface.BaseFile.name" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of this file. For example, File(&#8220;a&#8221;, &#8220;b&#8221;, &#8220;c&#8221;).name will be
&#8220;c&#8221;.</p>
<p>On Unix-based operating systems, File(&#8220;/&#8221;).name will be the empty
string.</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.open_for_reading">
<tt class="descname">open_for_reading</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.open_for_reading" title="Permalink to this definition">¶</a></dt>
<dd><p>Open this file for reading in binary mode and return a Python file-like
object from which this file&#8217;s contents can be read.</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.open_for_writing">
<tt class="descname">open_for_writing</tt><big>(</big><em>self</em>, <em>append=False</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.open_for_writing" title="Permalink to this definition">¶</a></dt>
<dd><p>Open this file for reading in binary mode and return a Python file-like
object from which this file&#8217;s contents can be read.</p>
<p>If append is False, the file&#8217;s contents will be erased and the returned
stream positioned at the beginning of the (now empty) file. If append
is True, the file&#8217;s contents will not be erased, and the returned
stream will be positioned at the end of the file.</p>
<p>Note that some implementations (e.g. SMBFile and FTPFile) don&#8217;t have
native support for writing files remotely; support in such
implementations can be emulated by returning a wrapper around a
temporary file that, when closed, uploads itself to the location of
the file to be written. As a result, objects returned from
open_for_writing should be closed before calling open_for_reading on
the same file.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.BaseFile.parent">
<tt class="descname">parent</tt><a class="headerlink" href="#fileutils.interface.BaseFile.parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a file representing the parent of this file. If this file has
no parent (for example, if it&#8217;s &#8220;/&#8221; on Unix-based operating systems or
a drive letter on Windows), None will be returned.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.BaseFile.path">
<tt class="descname">path</tt><a class="headerlink" href="#fileutils.interface.BaseFile.path" title="Permalink to this definition">¶</a></dt>
<dd><p>The absolute path to the file represented by this file object, in a
format native to the type of file in use. For instances of
fileutils.local.File, this pathname can be used with Python&#8217;s
traditional file-related utilities.</p>
<p>This property simply returns self.get_path(). See the documentation for
that method for more complex ways of creating paths (including
obtaining relative paths).</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.BaseFile.path_components">
<tt class="descname">path_components</tt><a class="headerlink" href="#fileutils.interface.BaseFile.path_components" title="Permalink to this definition">¶</a></dt>
<dd><p>A property that simply returns
<a class="reference internal" href="#fileutils.interface.BaseFile.get_path_components" title="fileutils.interface.BaseFile.get_path_components"><tt class="xref py py-obj docutils literal"><span class="pre">self.get_path_components()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.read">
<tt class="descname">read</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the contents of this file and return them as a string. This is
usually a bad idea if the file in question is large, as the entire
contents of the file will be loaded into memory.</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.read_blocks">
<tt class="descname">read_blocks</tt><big>(</big><em>self</em>, <em>block_size=None</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.read_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>A generator that yields successive blocks of data from this file. Each
block will be no larger than block_size bytes, which defaults to 16384.
This is useful when reading/processing files larger than would
otherwise fit into memory.</p>
<p>One could implement, for example, a copy function thus:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">target</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">target_stream</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">source</span><span class="o">.</span><span class="n">read_blocks</span><span class="p">():</span>
        <span class="n">target_stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.recurse">
<tt class="descname">recurse</tt><big>(</big><em>self</em>, <em>filter=None</em>, <em>include_self=True</em>, <em>recurse_skipped=True</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.recurse" title="Permalink to this definition">¶</a></dt>
<dd><p>A generator that recursively yields all child File objects of this file.
Files and directories (and the files and directories contained within
them, and so on) are all included.</p>
<p>A filter function accepting one argument can be specified. It will be
called for each file and folder. It can return one of True, False,
SKIP, YIELD, or RECURSE, with the behavior of each outlined in the
following table:</p>
<div class="highlight-python"><pre>                      Don't yield   Do yield
                    +-------------+----------+
Don't recurse into  | SKIP        | YIELD    |
                    +-------------+----------+
Do recurse into     | RECURSE     | True     |
                    +-------------+----------+

False behaves the same as RECURSE if recurse_skipped is True, or
SKIP otherwise.</pre>
</div>
<p>If include_self is True (the default), this file (a.k.a. self) will be
yielded as well (if it matches the specified filter function). If it&#8217;s
False, only this file&#8217;s children (and their children, and so on) will
be yielded.</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.rename_to">
<tt class="descname">rename_to</tt><big>(</big><em>self</em>, <em>other</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.rename_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename this file or folder to the specified name, which should be
another file object (but need not be of the same type as self).</p>
<p>The default implementation simply does:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">copy_to</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
<p>(which, as a note, doesn&#8217;t work for directories yet, so at present
directories can&#8217;t be renamed across different subclasses). Subclasses
are free to provide a more specialized implementation for renames to
files of the same type; File and SSHFile, for example, make use of
native functions to speed up such renames (and to allow them to work
with directories at present).</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.safe_child">
<tt class="descname">safe_child</tt><big>(</big><em>self</em>, <em>*names</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.safe_child" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.child(<a href="#id3"><span class="problematic" id="id4">*</span></a>names), but checks that the resulting file is a
descendant of self. If it&#8217;s not, an exception will be thrown. This
allows unsanitized paths to be used without fear that things like &#8221;..&#8221;
will be used to escape the confines of self.</p>
<p>The pathname may contain occurrences of &#8221;..&#8221; so long as they do not
escape self. For example, &#8220;a/b/../c&#8221; is perfectly fine, but &#8220;a/../..&#8221;
is not.</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.same_as">
<tt class="descname">same_as</tt><big>(</big><em>self</em>, <em>other</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.same_as" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if this file represents the same file as the specified
one, False otherwise.</p>
<p>This is usually the same as self == other, but URL implements this
differently: a URL with a trailing slash and a URL without are treated
as the same by same_as but different by ==.</p>
<p>The default implementation returns True if self.path_components ==
other.path_components and type(self) == type(other), or False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.sibling">
<tt class="descname">sibling</tt><big>(</big><em>self</em>, <em>*names</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.sibling" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a File object representing the sibling of this file with the
specified name. This is equivalent to self.parent.child(name).</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.BaseFile.size">
<tt class="descname">size</tt><a class="headerlink" href="#fileutils.interface.BaseFile.size" title="Permalink to this definition">¶</a></dt>
<dd><p>The size, in bytes, of this file. This is the number of bytes that the
file contains; the number of actual bytes of disk space it consumes is
usually larger.</p>
<p>If this file is actually a folder, the sizes of its child files and
folders will be recursively summed up and returned. This can take quite
some time for large folders.</p>
<p>This is the same as len(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.BaseFile.type">
<tt class="descname">type</tt><a class="headerlink" href="#fileutils.interface.BaseFile.type" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of this file. This can be one of FILE, FOLDER, or LINK (I
don&#8217;t yet have constants for block/character special devices; those
will come soon.) If the file does not exist, this should be None.</p>
</dd></dl>

<dl class="attribute">
<dt id="fileutils.interface.BaseFile.valid">
<tt class="descname">valid</tt><a class="headerlink" href="#fileutils.interface.BaseFile.valid" title="Permalink to this definition">¶</a></dt>
<dd><p>True if this file/folder exists, False if it doesn&#8217;t. This will be
False for broken symbolic links; use self.exists if you want an
alternative that returns True for broken symbolic links.</p>
</dd></dl>

<dl class="method">
<dt id="fileutils.interface.BaseFile.write">
<tt class="descname">write</tt><big>(</big><em>self</em>, <em>data</em>, <em>binary=True</em><big>)</big><a class="headerlink" href="#fileutils.interface.BaseFile.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrite this file with the specified data. After this is called,
self.size will be equal to len(data), and self.read() will be equal to
data. If you want to append data instead, use self.append().</p>
<p>If binary is True (the default), the file will be written
byte-for-byte. If it&#8217;s False, the file will be written in text mode.</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><tt class="docutils literal"><span class="pre">fileutils.interface</span></tt> &#8212; Abstract classes.</a><ul>
<li><a class="reference internal" href="#class-filesystem">Class FileSystem</a></li>
<li><a class="reference internal" href="#class-mountpoint">Class MountPoint</a></li>
<li><a class="reference internal" href="#class-mountdevice">Class MountDevice</a></li>
<li><a class="reference internal" href="#class-diskusage">Class DiskUsage</a></li>
<li><a class="reference internal" href="#class-usage">Class Usage</a></li>
<li><a class="reference internal" href="#class-basefile">Class BaseFile</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="fileutils.ftp.html"
                        title="previous chapter"><tt class="docutils literal docutils literal docutils literal"><span class="pre">fileutils.ftp</span></tt> &#8212;</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="fileutils.local.html"
                        title="next chapter"><tt class="docutils literal"><span class="pre">fileutils.local</span></tt> &#8212;</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/modules/fileutils.interface.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="fileutils.local.html" title="fileutils.local —"
             >next</a> |</li>
        <li class="right" >
          <a href="fileutils.ftp.html" title="fileutils.ftp —"
             >previous</a> |</li>
        <li><a href="../contents.html">Python  documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright .
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>